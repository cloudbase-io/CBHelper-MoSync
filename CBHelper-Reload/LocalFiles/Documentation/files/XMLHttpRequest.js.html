<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>XMLHttpRequest.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CBHelper.html">CBHelper</a></li>
            
                <li><a href="..&#x2F;classes/CBHelperCurrentLocation.html">CBHelperCurrentLocation</a></li>
            
                <li><a href="..&#x2F;classes/CBHelperResponseInfo.html">CBHelperResponseInfo</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: XMLHttpRequest.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
* XMLHttpRequest.js Copyright (C) 2011 Sergey Ilinsky (http:&#x2F;&#x2F;www.ilinsky.com)
*
* This work is free software; you can redistribute it and&#x2F;or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2.1 of the License, or
* (at your option) any later version.
*
* This work is distributed in the hope that it will be useful,
* but without any warranty; without even the implied warranty of
* merchantability or fitness for a particular purpose. See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this library; if not, write to the Free Software Foundation, Inc.,
* 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
*&#x2F;

(function () {

	&#x2F;&#x2F; Save reference to earlier defined object implementation (if any)
	var oXMLHttpRequest = window.XMLHttpRequest;

	&#x2F;&#x2F; Define on browser type
	var bGecko  = !!window.controllers;
	var bIE     = window.document.all &amp;&amp; !window.opera;
	var bIE7    = bIE &amp;&amp; window.navigator.userAgent.match(&#x2F;MSIE 7.0&#x2F;);

	&#x2F;&#x2F; Enables &quot;XMLHttpRequest()&quot; call next to &quot;new XMLHttpRequest()&quot;
	function fXMLHttpRequest() {
		this._object  = oXMLHttpRequest &amp;&amp; !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
		this._listeners = [];
	}

	&#x2F;&#x2F; Constructor
	function cXMLHttpRequest() {
		return new fXMLHttpRequest;
	}
	cXMLHttpRequest.prototype = fXMLHttpRequest.prototype;

	&#x2F;&#x2F; BUGFIX: Firefox with Firebug installed would break pages if not executed
	if (bGecko &amp;&amp; oXMLHttpRequest.wrapped) {
		cXMLHttpRequest.wrapped = oXMLHttpRequest.wrapped;
	}

	&#x2F;&#x2F; Constants
	cXMLHttpRequest.UNSENT            = 0;
	cXMLHttpRequest.OPENED            = 1;
	cXMLHttpRequest.HEADERS_RECEIVED  = 2;
	cXMLHttpRequest.LOADING           = 3;
	cXMLHttpRequest.DONE              = 4;

	&#x2F;&#x2F; Interface level constants
	cXMLHttpRequest.prototype.UNSENT            = cXMLHttpRequest.UNSENT;
	cXMLHttpRequest.prototype.OPENED            = cXMLHttpRequest.OPENED;
	cXMLHttpRequest.prototype.HEADERS_RECEIVED  = cXMLHttpRequest.HEADERS_RECEIVED;
	cXMLHttpRequest.prototype.LOADING           = cXMLHttpRequest.LOADING;
	cXMLHttpRequest.prototype.DONE              = cXMLHttpRequest.DONE;

	&#x2F;&#x2F; Public Properties
	cXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;
	cXMLHttpRequest.prototype.responseText  = &#x27;&#x27;;
	cXMLHttpRequest.prototype.responseXML   = null;
	cXMLHttpRequest.prototype.status        = 0;
	cXMLHttpRequest.prototype.statusText    = &#x27;&#x27;;

	&#x2F;&#x2F; Priority proposal
	cXMLHttpRequest.prototype.priority    = &quot;NORMAL&quot;;

	&#x2F;&#x2F; Instance-level Events Handlers
	cXMLHttpRequest.prototype.onreadystatechange  = null;

	&#x2F;&#x2F; Class-level Events Handlers
	cXMLHttpRequest.onreadystatechange  = null;
	cXMLHttpRequest.onopen              = null;
	cXMLHttpRequest.onsend              = null;
	cXMLHttpRequest.onabort             = null;

	&#x2F;&#x2F; Public Methods
	cXMLHttpRequest.prototype.open  = function(sMethod, sUrl, bAsync, sUser, sPassword) {
		&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;XMLHttpRequest&#x2F;#the-open-method
		var backlist = sMethod.toLowerCase();
		if((backlist == &quot;connect&quot;) || (backlist == &quot;trace&quot;) || (backlist == &quot;track&quot;)){
			&#x2F;&#x2F; Using a generic error and an int - not too sure all browsers support correctly
			&#x2F;&#x2F; http:&#x2F;&#x2F;dvcs.w3.org&#x2F;hg&#x2F;domcore&#x2F;raw-file&#x2F;tip&#x2F;Overview.html#securityerror, so, this is safer
			&#x2F;&#x2F; XXX should do better than that, but this is OT to XHR.
			throw new Error(18);
		}

		&#x2F;&#x2F; Delete headers, required when object is reused
		delete this._headers;

		&#x2F;&#x2F; When bAsync parameter value is omitted, use true as default
		if (arguments.length &lt; 3) {
			bAsync  = true;
		}

		&#x2F;&#x2F; Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests
		this._async   = bAsync;

		&#x2F;&#x2F; Set the onreadystatechange handler
		var oRequest  = this;
		var nState    = this.readyState;
		var fOnUnload = null;

		&#x2F;&#x2F; BUGFIX: IE - memory leak on page unload (inter-page leak)
		if (bIE &amp;&amp; bAsync) {
			fOnUnload = function() {
				if (nState != cXMLHttpRequest.DONE) {
					fCleanTransport(oRequest);
					&#x2F;&#x2F; Safe to abort here since onreadystatechange handler removed
					oRequest.abort();
				}
			};
			window.attachEvent(&quot;onunload&quot;, fOnUnload);
		}

		&#x2F;&#x2F; Add method sniffer
		if (cXMLHttpRequest.onopen) {
			cXMLHttpRequest.onopen.apply(this, arguments);
		}

		if (arguments.length &gt; 4) {
			this._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
		} else if (arguments.length &gt; 3) {
			this._object.open(sMethod, sUrl, bAsync, sUser);
		} else {
			this._object.open(sMethod, sUrl, bAsync);
		}

		this.readyState = cXMLHttpRequest.OPENED;
		fReadyStateChange(this);

		this._object.onreadystatechange = function() {
			if (bGecko &amp;&amp; !bAsync) {
				return;
			}

			&#x2F;&#x2F; Synchronize state
			oRequest.readyState   = oRequest._object.readyState;
			fSynchronizeValues(oRequest);

			&#x2F;&#x2F; BUGFIX: Firefox fires unnecessary DONE when aborting
			if (oRequest._aborted) {
				&#x2F;&#x2F; Reset readyState to UNSENT
				oRequest.readyState = cXMLHttpRequest.UNSENT;

				&#x2F;&#x2F; Return now
				return;
			}

			if (oRequest.readyState == cXMLHttpRequest.DONE) {
				&#x2F;&#x2F; Free up queue
				delete oRequest._data;

				&#x2F;&#x2F; Uncomment these lines for bAsync
				&#x2F;**
				 * if (bAsync) {
				 * 	fQueue_remove(oRequest);
				 * }
				 *&#x2F;

				fCleanTransport(oRequest);

				&#x2F;&#x2F; Uncomment this block if you need a fix for IE cache
				&#x2F;**
				 * &#x2F;&#x2F; BUGFIX: IE - cache issue
				 * if (!oRequest._object.getResponseHeader(&quot;Date&quot;)) {
				 * 	&#x2F;&#x2F; Save object to cache
				 * 	oRequest._cached  = oRequest._object;
				 *
				 * 	&#x2F;&#x2F; Instantiate a new transport object
				 * 	cXMLHttpRequest.call(oRequest);
				 *
				 * 	&#x2F;&#x2F; Re-send request
				 * 	if (sUser) {
				 * 		if (sPassword) {
				 * 			oRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
				 * 		} else {
				 * 			oRequest._object.open(sMethod, sUrl, bAsync);
				 * 		}
				 *
				 * 		oRequest._object.setRequestHeader(&quot;If-Modified-Since&quot;, oRequest._cached.getResponseHeader(&quot;Last-Modified&quot;) || new window.Date(0));
				 * 		&#x2F;&#x2F; Copy headers set
				 * 		if (oRequest._headers) {
				 * 			for (var sHeader in oRequest._headers) {
				 * 				&#x2F;&#x2F; Some frameworks prototype objects with functions
				 * 				if (typeof oRequest._headers[sHeader] == &quot;string&quot;) {
				 * 					oRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);
				 * 				}
				 * 			}
				 * 		}
				 * 		oRequest._object.onreadystatechange = function() {
				 * 			&#x2F;&#x2F; Synchronize state
				 * 			oRequest.readyState   = oRequest._object.readyState;
				 *
				 * 			if (oRequest._aborted) {
				 * 				&#x2F;&#x2F;
				 * 				oRequest.readyState = cXMLHttpRequest.UNSENT;
				 *
				 * 				&#x2F;&#x2F; Return
				 * 				return;
				 * 			}
				 *
				 * 			if (oRequest.readyState == cXMLHttpRequest.DONE) {
				 * 				&#x2F;&#x2F; Clean Object
				 * 				fCleanTransport(oRequest);
				 *
				 * 				&#x2F;&#x2F; get cached request
				 * 				if (oRequest.status == 304) {
				 * 					oRequest._object  = oRequest._cached;
				 * 				}
				 *
				 * 				&#x2F;&#x2F;
				 * 				delete oRequest._cached;
				 *
				 * 				&#x2F;&#x2F;
				 * 				fSynchronizeValues(oRequest);
				 *
				 * 				&#x2F;&#x2F;
				 * 				fReadyStateChange(oRequest);
				 *
				 * 				&#x2F;&#x2F; BUGFIX: IE - memory leak in interrupted
				 * 				if (bIE &amp;&amp; bAsync) {
				 * 					window.detachEvent(&quot;onunload&quot;, fOnUnload);
				 * 				}
				 *
				 * 			}
				 * 		};
				 * 		oRequest._object.send(null);
				 *
				 * 		&#x2F;&#x2F; Return now - wait until re-sent request is finished
				 * 		return;
				 * 	};
				 *&#x2F;

				&#x2F;&#x2F; BUGFIX: IE - memory leak in interrupted
				if (bIE &amp;&amp; bAsync) {
					window.detachEvent(&quot;onunload&quot;, fOnUnload);
				}

				&#x2F;&#x2F; BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice
				if (nState != oRequest.readyState) {
					fReadyStateChange(oRequest);
				}

				nState  = oRequest.readyState;
			}
		};
	};

	cXMLHttpRequest.prototype.send = function(vData) {
		&#x2F;&#x2F; Add method sniffer
		if (cXMLHttpRequest.onsend) {
			cXMLHttpRequest.onsend.apply(this, arguments);
		}

		if (!arguments.length) {
			vData = null;
		}

		&#x2F;&#x2F; BUGFIX: Safari - fails sending documents created&#x2F;modified dynamically, so an explicit serialization required
		&#x2F;&#x2F; BUGFIX: IE - rewrites any custom mime-type to &quot;text&#x2F;xml&quot; in case an XMLNode is sent
		&#x2F;&#x2F; BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)
		if (vData &amp;&amp; vData.nodeType) {
			vData = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;
			if (!this._headers[&quot;Content-Type&quot;]) {
				this._object.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;xml&quot;);
			}
		}

		this._data = vData;

		&#x2F;**
		 * &#x2F;&#x2F; Add to queue
		 * if (this._async) {
		 * 	fQueue_add(this);
		 * } else { *&#x2F;
		fXMLHttpRequest_send(this);
		 &#x2F;**
		 * }
		 *&#x2F;
	};

	cXMLHttpRequest.prototype.abort = function() {
		&#x2F;&#x2F; Add method sniffer
		if (cXMLHttpRequest.onabort) {
			cXMLHttpRequest.onabort.apply(this, arguments);
		}

		&#x2F;&#x2F; BUGFIX: Gecko - unnecessary DONE when aborting
		if (this.readyState &gt; cXMLHttpRequest.UNSENT) {
			this._aborted = true;
		}

		this._object.abort();

		&#x2F;&#x2F; BUGFIX: IE - memory leak
		fCleanTransport(this);

		this.readyState = cXMLHttpRequest.UNSENT;

		delete this._data;

		&#x2F;* if (this._async) {
	 	* 	fQueue_remove(this);
	 	* }
	 	*&#x2F;
	};

	cXMLHttpRequest.prototype.getAllResponseHeaders = function() {
		return this._object.getAllResponseHeaders();
	};

	cXMLHttpRequest.prototype.getResponseHeader = function(sName) {
		return this._object.getResponseHeader(sName);
	};

	cXMLHttpRequest.prototype.setRequestHeader  = function(sName, sValue) {
		&#x2F;&#x2F; BUGFIX: IE - cache issue
		if (!this._headers) {
			this._headers = {};
		}

		this._headers[sName]  = sValue;

		return this._object.setRequestHeader(sName, sValue);
	};

	&#x2F;&#x2F; EventTarget interface implementation
	cXMLHttpRequest.prototype.addEventListener  = function(sName, fHandler, bUseCapture) {
		for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {
			if (oListener[0] == sName &amp;&amp; oListener[1] == fHandler &amp;&amp; oListener[2] == bUseCapture) {
				return;
			}
		}

		&#x2F;&#x2F; Add listener
		this._listeners.push([sName, fHandler, bUseCapture]);
	};

	cXMLHttpRequest.prototype.removeEventListener = function(sName, fHandler, bUseCapture) {
		for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {
			if (oListener[0] == sName &amp;&amp; oListener[1] == fHandler &amp;&amp; oListener[2] == bUseCapture) {
				break;
			}
		}

		&#x2F;&#x2F; Remove listener
		if (oListener) {
			this._listeners.splice(nIndex, 1);
		}
	};

	cXMLHttpRequest.prototype.dispatchEvent = function(oEvent) {
		var oEventPseudo  = {
			&#x27;type&#x27;:             oEvent.type,
			&#x27;target&#x27;:           this,
			&#x27;currentTarget&#x27;:    this,
			&#x27;eventPhase&#x27;:       2,
			&#x27;bubbles&#x27;:          oEvent.bubbles,
			&#x27;cancelable&#x27;:       oEvent.cancelable,
			&#x27;timeStamp&#x27;:        oEvent.timeStamp,
			&#x27;stopPropagation&#x27;:  function() {},  &#x2F;&#x2F; There is no flow
			&#x27;preventDefault&#x27;:   function() {},  &#x2F;&#x2F; There is no default action
			&#x27;initEvent&#x27;:        function() {}   &#x2F;&#x2F; Original event object should be initialized
		};

		&#x2F;&#x2F; Execute onreadystatechange
		if (oEventPseudo.type == &quot;readystatechange&quot; &amp;&amp; this.onreadystatechange) {
			(this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);
		}


		&#x2F;&#x2F; Execute listeners
		for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {
			if (oListener[0] == oEventPseudo.type &amp;&amp; !oListener[2]) {
				(oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);
			}
		}

	};

	&#x2F;&#x2F;
	cXMLHttpRequest.prototype.toString  = function() {
		return &#x27;[&#x27; + &quot;object&quot; + &#x27; &#x27; + &quot;XMLHttpRequest&quot; + &#x27;]&#x27;;
	};

	cXMLHttpRequest.toString  = function() {
		return &#x27;[&#x27; + &quot;XMLHttpRequest&quot; + &#x27;]&#x27;;
	};

	&#x2F;**
	 * &#x2F;&#x2F; Queue manager
	 * var oQueuePending = {&quot;CRITICAL&quot;:[],&quot;HIGH&quot;:[],&quot;NORMAL&quot;:[],&quot;LOW&quot;:[],&quot;LOWEST&quot;:[]},
	 * aQueueRunning = [];
	 * function fQueue_add(oRequest) {
	 * 	oQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : &quot;NORMAL&quot;].push(oRequest);
	 * 	&#x2F;&#x2F;
	 * 	setTimeout(fQueue_process);
	 * };
	 *
	 * function fQueue_remove(oRequest) {
	 * 	for (var nIndex = 0, bFound = false; nIndex &lt; aQueueRunning.length; nIndex++)
	 * 	if (bFound) {
	 * 		aQueueRunning[nIndex - 1] = aQueueRunning[nIndex];
	 * 	} else {
	 * 		if (aQueueRunning[nIndex] == oRequest) {
	 * 			bFound  = true;
	 * 		}
	 * }
	 *
	 * 	if (bFound) {
	 * 		aQueueRunning.length--;
	 * 	}
	 *
	 *
	 * 	&#x2F;&#x2F;
	 * 	setTimeout(fQueue_process);
	 * };
	 *
	 * function fQueue_process() {
	 * if (aQueueRunning.length &lt; 6) {
	 * for (var sPriority in oQueuePending) {
	 * if (oQueuePending[sPriority].length) {
	 * var oRequest  = oQueuePending[sPriority][0];
	 * oQueuePending[sPriority]  = oQueuePending[sPriority].slice(1);
	 * &#x2F;&#x2F;
	 * aQueueRunning.push(oRequest);
	 * &#x2F;&#x2F; Send request
	 * fXMLHttpRequest_send(oRequest);
	 * break;
	 * }
	 * }
	 * }
	 * };
	 *&#x2F;

	&#x2F;&#x2F; Helper function
	function fXMLHttpRequest_send(oRequest) {
		oRequest._object.send(oRequest._data);

		&#x2F;&#x2F; BUGFIX: Gecko - missing readystatechange calls in synchronous requests
		if (bGecko &amp;&amp; !oRequest._async) {
			oRequest.readyState = cXMLHttpRequest.OPENED;

			&#x2F;&#x2F; Synchronize state
			fSynchronizeValues(oRequest);

			&#x2F;&#x2F; Simulate missing states
			while (oRequest.readyState &lt; cXMLHttpRequest.DONE) {
				oRequest.readyState++;
				fReadyStateChange(oRequest);
				&#x2F;&#x2F; Check if we are aborted
				if (oRequest._aborted) {
					return;
				}
			}
		}
	}

	function fReadyStateChange(oRequest) {
		&#x2F;&#x2F; Sniffing code
		if (cXMLHttpRequest.onreadystatechange){
			cXMLHttpRequest.onreadystatechange.apply(oRequest);
		}


		&#x2F;&#x2F; Fake event
		oRequest.dispatchEvent({
			&#x27;type&#x27;:       &quot;readystatechange&quot;,
			&#x27;bubbles&#x27;:    false,
			&#x27;cancelable&#x27;: false,
			&#x27;timeStamp&#x27;:  new Date + 0
		});
	}

	function fGetDocument(oRequest) {
		var oDocument = oRequest.responseXML;
		var sResponse = oRequest.responseText;
		&#x2F;&#x2F; Try parsing responseText
		if (bIE &amp;&amp; sResponse &amp;&amp; oDocument &amp;&amp; !oDocument.documentElement &amp;&amp; oRequest.getResponseHeader(&quot;Content-Type&quot;).match(&#x2F;[^\&#x2F;]+\&#x2F;[^\+]+\+xml&#x2F;)) {
			oDocument = new window.ActiveXObject(&quot;Microsoft.XMLDOM&quot;);
			oDocument.async       = false;
			oDocument.validateOnParse = false;
			oDocument.loadXML(sResponse);
		}

		&#x2F;&#x2F; Check if there is no error in document
		if (oDocument){
			if ((bIE &amp;&amp; oDocument.parseError !== 0) || !oDocument.documentElement || (oDocument.documentElement &amp;&amp; oDocument.documentElement.tagName == &quot;parsererror&quot;)) {
				return null;
			}
		}
		return oDocument;
	}

	function fSynchronizeValues(oRequest) {
		try { oRequest.responseText = oRequest._object.responseText;  } catch (e) {}
		try { oRequest.responseXML  = fGetDocument(oRequest._object); } catch (e) {}
		try { oRequest.status       = oRequest._object.status;        } catch (e) {}
		try { oRequest.statusText   = oRequest._object.statusText;    } catch (e) {}
	}

	function fCleanTransport(oRequest) {
		&#x2F;&#x2F; BUGFIX: IE - memory leak (on-page leak)
		oRequest._object.onreadystatechange = new window.Function;
	}

	&#x2F;&#x2F; Internet Explorer 5.0 (missing apply)
	if (!window.Function.prototype.apply) {
		window.Function.prototype.apply = function(oRequest, oArguments) {
			if (!oArguments) {
				oArguments  = [];
			}
			oRequest.__func = this;
			oRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);
			delete oRequest.__func;
		};
	}

	&#x2F;&#x2F; Register new object with window
	window.XMLHttpRequest = cXMLHttpRequest;

})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
